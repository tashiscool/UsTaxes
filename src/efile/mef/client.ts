/**
 * IRS MeF (Modernized e-File) SOAP Web Services Client
 *
 * This module provides a SOAP client for communicating with IRS MeF
 * web services for electronic tax return submission.
 */

import log from '../../core/log'

// ============================================================================
// Types and Interfaces
// ============================================================================

/**
 * MeF environment configuration
 */
export interface MeFConfig {
  environment: 'ATS' | 'Production'
  credentials: MeFCredentials
  timeout?: number
  retryAttempts?: number
  retryDelayMs?: number
  enableLogging?: boolean
}

/**
 * Authentication credentials for MeF
 */
export interface MeFCredentials {
  /** ETIN (Electronic Transmitter Identification Number) */
  etin: string
  /** Application ID assigned by IRS */
  appSystemId: string
  /** Username for UsernameToken authentication */
  username?: string
  /** Password for UsernameToken authentication */
  password?: string
  /** X.509 certificate in PEM format for certificate-based auth */
  certificate?: string
  /** Private key for X.509 authentication */
  privateKey?: string
}

/**
 * Login response from MeF
 */
export interface LoginResponse {
  sessionId: string
  expirationTime: Date
  etin: string
}

/**
 * Return submission request
 */
export interface ReturnSubmission {
  /** Unique submission ID generated by transmitter */
  submissionId: string
  /** Tax year */
  taxYear: number
  /** Return type (e.g., '1040', '1040SR') */
  returnType: string
  /** Base64 encoded return XML */
  returnData: string
  /** Taxpayer identification */
  taxpayerTin: string
  /** Optional state submission data */
  stateSubmissions?: StateSubmissionData[]
}

/**
 * State submission data for linked state e-file
 */
export interface StateSubmissionData {
  stateCode: string
  submissionId: string
  returnData: string
}

/**
 * Response from return submission
 */
export interface SubmitResponse {
  submissionId: string
  timestamp: Date
  receiptId: string
  status: 'Received' | 'Rejected' | 'Processing'
  errors?: SubmissionError[]
}

/**
 * Submission error detail
 */
export interface SubmissionError {
  errorCode: string
  errorMessage: string
  errorCategory: 'Schema' | 'Business' | 'System'
  xpath?: string
}

/**
 * Acknowledgment from IRS
 */
export interface Acknowledgment {
  submissionId: string
  status: AcknowledgmentStatus
  timestamp: Date
  acceptanceStatus?: 'Accepted' | 'Rejected'
  errors?: AcknowledgmentError[]
  stateAcknowledgments?: StateAcknowledgment[]
}

/**
 * Acknowledgment status values
 */
export type AcknowledgmentStatus =
  | 'Pending'
  | 'Accepted'
  | 'Rejected'
  | 'AcceptedWithErrors'

/**
 * Acknowledgment error detail
 */
export interface AcknowledgmentError {
  errorCode: string
  errorMessage: string
  ruleNumber?: string
  severity: 'Error' | 'Warning' | 'Alert'
}

/**
 * State acknowledgment information
 */
export interface StateAcknowledgment {
  stateCode: string
  submissionId: string
  status: AcknowledgmentStatus
  errors?: AcknowledgmentError[]
}

/**
 * Submission status response
 */
export interface SubmissionStatus {
  submissionId: string
  status: 'Received' | 'Processing' | 'Completed' | 'Error'
  lastUpdated: Date
  acknowledgmentAvailable: boolean
}

/**
 * State submission retrieval response
 */
export interface StateSubmission {
  submissionId: string
  stateCode: string
  returnData: string
  status: string
}

// ============================================================================
// Error Classes
// ============================================================================

/**
 * Error categories for MeF operations
 */
export type MeFErrorCategory =
  | 'Authentication'
  | 'Validation'
  | 'System'
  | 'Network'
  | 'Timeout'
  | 'SOAPFault'

/**
 * MeF-specific error class
 */
export class MeFError extends Error {
  readonly category: MeFErrorCategory
  readonly code: string
  readonly details?: string
  readonly soapFaultCode?: string
  readonly soapFaultString?: string
  readonly retryable: boolean

  constructor(
    message: string,
    category: MeFErrorCategory,
    code: string,
    options?: {
      details?: string
      soapFaultCode?: string
      soapFaultString?: string
      retryable?: boolean
    }
  ) {
    super(message)
    this.name = 'MeFError'
    this.category = category
    this.code = code
    this.details = options?.details
    this.soapFaultCode = options?.soapFaultCode
    this.soapFaultString = options?.soapFaultString
    this.retryable = options?.retryable ?? false
  }
}

// ============================================================================
// Constants
// ============================================================================

/**
 * MeF service endpoints
 */
export const ENDPOINTS = {
  ATS: {
    wsdl: 'https://la.www4.irs.gov/a2a/MEFATS/MeFTransmitterService.wsdl',
    service: 'https://la.www4.irs.gov/a2a/MEFATS/MeFTransmitterService'
  },
  Production: {
    wsdl: 'https://la.www4.irs.gov/a2a/MEF/MeFTransmitterService.wsdl',
    service: 'https://la.www4.irs.gov/a2a/MEF/MeFTransmitterService'
  }
} as const

/**
 * SOAP namespaces
 */
const NAMESPACES = {
  soap: 'http://schemas.xmlsoap.org/soap/envelope/',
  wsse: 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd',
  wsu: 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd',
  mef: 'http://www.irs.gov/mef/transmitter'
} as const

/**
 * Default configuration values
 */
const DEFAULTS = {
  timeout: 60000,
  retryAttempts: 3,
  retryDelayMs: 1000
} as const

// ============================================================================
// SOAP Envelope Builder
// ============================================================================

/**
 * Builder for SOAP 1.1 envelopes with WS-Security headers
 */
class SoapEnvelopeBuilder {
  private credentials: MeFCredentials
  private messageId: string

  constructor(credentials: MeFCredentials) {
    this.credentials = credentials
    this.messageId = this.generateMessageId()
  }

  /**
   * Generate unique message ID
   */
  private generateMessageId(): string {
    const timestamp = Date.now().toString(36)
    const random = Math.random().toString(36).substring(2, 15)
    return `${timestamp}-${random}`
  }

  /**
   * Generate ISO timestamp
   */
  private generateTimestamp(): { created: string; expires: string } {
    const now = new Date()
    const expires = new Date(now.getTime() + 5 * 60 * 1000) // 5 minutes
    return {
      created: now.toISOString(),
      expires: expires.toISOString()
    }
  }

  /**
   * Build WS-Security header with UsernameToken
   */
  private buildSecurityHeader(): string {
    const { created, expires } = this.generateTimestamp()

    let securityContent = `
      <wsu:Timestamp wsu:Id="TS-${this.messageId}">
        <wsu:Created>${created}</wsu:Created>
        <wsu:Expires>${expires}</wsu:Expires>
      </wsu:Timestamp>`

    if (this.credentials.username && this.credentials.password) {
      securityContent += `
      <wsse:UsernameToken wsu:Id="UT-${this.messageId}">
        <wsse:Username>${this.escapeXml(
          this.credentials.username
        )}</wsse:Username>
        <wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">${this.escapeXml(
          this.credentials.password
        )}</wsse:Password>
      </wsse:UsernameToken>`
    }

    if (this.credentials.certificate) {
      securityContent += `
      <wsse:BinarySecurityToken
        EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"
        ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3"
        wsu:Id="X509-${this.messageId}">
        ${this.credentials.certificate.replace(
          /-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----|\n/g,
          ''
        )}
      </wsse:BinarySecurityToken>`
    }

    return `
    <wsse:Security xmlns:wsse="${NAMESPACES.wsse}" xmlns:wsu="${NAMESPACES.wsu}">
      ${securityContent}
    </wsse:Security>`
  }

  /**
   * Escape XML special characters
   */
  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
  }

  /**
   * Build complete SOAP envelope
   */
  build(action: string, body: string): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope
  xmlns:soap="${NAMESPACES.soap}"
  xmlns:mef="${NAMESPACES.mef}">
  <soap:Header>
    ${this.buildSecurityHeader()}
  </soap:Header>
  <soap:Body>
    <mef:${action}>
      ${body}
    </mef:${action}>
  </soap:Body>
</soap:Envelope>`
  }
}

// ============================================================================
// SOAP Response Parser
// ============================================================================

/**
 * Parser for SOAP responses
 */
class SoapResponseParser {
  private xml: string

  constructor(xml: string) {
    this.xml = xml
  }

  /**
   * Check if response contains a SOAP fault
   */
  hasFault(): boolean {
    return (
      this.xml.includes('soap:Fault') ||
      this.xml.includes('Fault') ||
      this.xml.includes('faultcode')
    )
  }

  /**
   * Extract SOAP fault details
   */
  extractFault(): { faultCode: string; faultString: string; detail?: string } {
    const faultCode = this.extractElement('faultcode') || 'Unknown'
    const faultString =
      this.extractElement('faultstring') || 'Unknown SOAP fault'
    const detail = this.extractElement('detail')

    return { faultCode, faultString, detail }
  }

  /**
   * Extract text content of an XML element
   */
  extractElement(tagName: string): string | undefined {
    // Handle namespaced and non-namespaced elements
    const patterns = [
      new RegExp(`<${tagName}[^>]*>([^<]*)</${tagName}>`, 'i'),
      new RegExp(`<[^:]+:${tagName}[^>]*>([^<]*)</[^:]+:${tagName}>`, 'i'),
      new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)</${tagName}>`, 'i')
    ]

    for (const pattern of patterns) {
      const match = this.xml.match(pattern)
      if (match) {
        return match[1].trim()
      }
    }

    return undefined
  }

  /**
   * Extract multiple elements with the same tag name
   */
  extractElements(tagName: string): string[] {
    const results: string[] = []
    const patterns = [
      new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)</${tagName}>`, 'gi'),
      new RegExp(`<[^:]+:${tagName}[^>]*>([\\s\\S]*?)</[^:]+:${tagName}>`, 'gi')
    ]

    for (const pattern of patterns) {
      let match
      while ((match = pattern.exec(this.xml)) !== null) {
        results.push(match[1].trim())
      }
    }

    return results
  }

  /**
   * Extract an attribute value from an element
   */
  extractAttribute(tagName: string, attrName: string): string | undefined {
    const pattern = new RegExp(
      `<(?:[^:]+:)?${tagName}[^>]*${attrName}="([^"]*)"`,
      'i'
    )
    const match = this.xml.match(pattern)
    return match ? match[1] : undefined
  }
}

// ============================================================================
// Audit Logger
// ============================================================================

/**
 * Audit logger for compliance requirements
 */
class AuditLogger {
  private enabled: boolean

  constructor(enabled = true) {
    this.enabled = enabled
  }

  /**
   * Sanitize sensitive data from log output
   */
  private sanitize(data: string): string {
    return data
      .replace(
        /<wsse:Password[^>]*>[^<]*<\/wsse:Password>/gi,
        '<wsse:Password>[REDACTED]</wsse:Password>'
      )
      .replace(
        /<Password[^>]*>[^<]*<\/Password>/gi,
        '<Password>[REDACTED]</Password>'
      )
      .replace(/<SSN>[^<]*<\/SSN>/gi, '<SSN>[REDACTED]</SSN>')
      .replace(/<TIN>[^<]*<\/TIN>/gi, '<TIN>[REDACTED]</TIN>')
      .replace(
        /<TaxpayerTin>[^<]*<\/TaxpayerTin>/gi,
        '<TaxpayerTin>[REDACTED]</TaxpayerTin>'
      )
      .replace(/\d{3}-\d{2}-\d{4}/g, 'XXX-XX-XXXX')
      .replace(/\d{2}-\d{7}/g, 'XX-XXXXXXX')
      .replace(
        /<BinarySecurityToken[^>]*>[^<]*<\/BinarySecurityToken>/gi,
        '<BinarySecurityToken>[REDACTED]</BinarySecurityToken>'
      )
  }

  /**
   * Log request
   */
  logRequest(
    action: string,
    endpoint: string,
    body: string,
    messageId: string
  ): void {
    if (!this.enabled) return

    log.info(`[MeF Request] MessageId: ${messageId}`)
    log.info(`[MeF Request] Action: ${action}`)
    log.info(`[MeF Request] Endpoint: ${endpoint}`)
    log.debug(`[MeF Request] Body:\n${this.sanitize(body)}`)
  }

  /**
   * Log response
   */
  logResponse(
    action: string,
    statusCode: number,
    body: string,
    messageId: string,
    durationMs: number
  ): void {
    if (!this.enabled) return

    log.info(`[MeF Response] MessageId: ${messageId}`)
    log.info(`[MeF Response] Action: ${action}`)
    log.info(`[MeF Response] Status: ${statusCode}`)
    log.info(`[MeF Response] Duration: ${durationMs}ms`)
    log.debug(`[MeF Response] Body:\n${this.sanitize(body)}`)
  }

  /**
   * Log error
   */
  logError(action: string, error: Error, messageId: string): void {
    if (!this.enabled) return

    log.error(`[MeF Error] MessageId: ${messageId}`)
    log.error(`[MeF Error] Action: ${action}`)
    log.error(`[MeF Error] Message: ${error.message}`)

    if (error instanceof MeFError) {
      log.error(`[MeF Error] Category: ${error.category}`)
      log.error(`[MeF Error] Code: ${error.code}`)
      if (error.details) {
        log.error(`[MeF Error] Details: ${error.details}`)
      }
    }
  }
}

// ============================================================================
// MeF Client
// ============================================================================

/**
 * Main MeF SOAP client class
 */
export class MeFClient {
  private config: Required<MeFConfig>
  private sessionId: string | null = null
  private sessionExpiry: Date | null = null
  private auditLogger: AuditLogger

  constructor(config: MeFConfig) {
    this.config = {
      environment: config.environment,
      credentials: config.credentials,
      timeout: config.timeout ?? DEFAULTS.timeout,
      retryAttempts: config.retryAttempts ?? DEFAULTS.retryAttempts,
      retryDelayMs: config.retryDelayMs ?? DEFAULTS.retryDelayMs,
      enableLogging: config.enableLogging ?? true
    }
    this.auditLogger = new AuditLogger(this.config.enableLogging)
  }

  /**
   * Get the service endpoint URL for the configured environment
   */
  private getEndpoint(): string {
    return ENDPOINTS[this.config.environment].service
  }

  /**
   * Generate unique message ID for tracking
   */
  private generateMessageId(): string {
    const timestamp = Date.now().toString(36)
    const random = Math.random().toString(36).substring(2, 15)
    return `mef-${timestamp}-${random}`
  }

  /**
   * Execute SOAP request with retry logic
   */
  private async executeRequest(action: string, body: string): Promise<string> {
    const messageId = this.generateMessageId()
    const endpoint = this.getEndpoint()
    const builder = new SoapEnvelopeBuilder(this.config.credentials)
    const envelope = builder.build(action, body)

    this.auditLogger.logRequest(action, endpoint, envelope, messageId)

    let lastError: Error | null = null
    const startTime = Date.now()

    for (let attempt = 1; attempt <= this.config.retryAttempts; attempt++) {
      try {
        const response = await this.sendRequest(endpoint, envelope, action)
        const durationMs = Date.now() - startTime

        this.auditLogger.logResponse(
          action,
          response.status,
          response.body,
          messageId,
          durationMs
        )

        if (!response.ok) {
          throw this.createErrorFromResponse(response)
        }

        const parser = new SoapResponseParser(response.body)
        if (parser.hasFault()) {
          const fault = parser.extractFault()
          throw new MeFError(fault.faultString, 'SOAPFault', fault.faultCode, {
            soapFaultCode: fault.faultCode,
            soapFaultString: fault.faultString,
            details: fault.detail,
            retryable: this.isFaultRetryable(fault.faultCode)
          })
        }

        return response.body
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error))
        this.auditLogger.logError(action, lastError, messageId)

        const isRetryable =
          error instanceof MeFError
            ? error.retryable
            : this.isRetryableError(error)

        if (!isRetryable || attempt >= this.config.retryAttempts) {
          throw error
        }

        // Exponential backoff
        const delay = this.config.retryDelayMs * Math.pow(2, attempt - 1)
        await this.sleep(delay)
      }
    }

    throw lastError ?? new Error('Unknown error during request execution')
  }

  /**
   * Send HTTP request
   */
  private async sendRequest(
    endpoint: string,
    body: string,
    action: string
  ): Promise<{ ok: boolean; status: number; body: string }> {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout)

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/xml; charset=utf-8',
          SOAPAction: `"${NAMESPACES.mef}/${action}"`,
          Accept: 'text/xml',
          'User-Agent': 'UsTaxes-MeFClient/1.0'
        },
        body,
        signal: controller.signal
      })

      const responseBody = await response.text()

      return {
        ok: response.ok,
        status: response.status,
        body: responseBody
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new MeFError('Request timed out', 'Timeout', 'TIMEOUT', {
          retryable: true
        })
      }
      throw new MeFError(
        `Network error: ${error instanceof Error ? error.message : 'Unknown'}`,
        'Network',
        'NETWORK_ERROR',
        { retryable: true }
      )
    } finally {
      clearTimeout(timeoutId)
    }
  }

  /**
   * Create error from HTTP response
   */
  private createErrorFromResponse(response: {
    status: number
    body: string
  }): MeFError {
    if (response.status === 401 || response.status === 403) {
      return new MeFError(
        'Authentication failed',
        'Authentication',
        `HTTP_${response.status}`,
        { details: response.body, retryable: false }
      )
    }

    if (response.status >= 500) {
      return new MeFError('Server error', 'System', `HTTP_${response.status}`, {
        details: response.body,
        retryable: true
      })
    }

    return new MeFError(
      `Request failed with status ${response.status}`,
      'System',
      `HTTP_${response.status}`,
      { details: response.body, retryable: false }
    )
  }

  /**
   * Check if a SOAP fault code indicates a retryable error
   */
  private isFaultRetryable(faultCode: string): boolean {
    const retryableFaults = [
      'Server',
      'soap:Server',
      'SYSTEM_ERROR',
      'SERVICE_UNAVAILABLE'
    ]
    return retryableFaults.some((f) =>
      faultCode.toLowerCase().includes(f.toLowerCase())
    )
  }

  /**
   * Check if an error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (error instanceof MeFError) {
      return error.retryable
    }

    // Network errors are typically retryable
    if (error instanceof TypeError) {
      return true
    }

    return false
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  /**
   * Check if current session is valid
   */
  private isSessionValid(): boolean {
    if (!this.sessionId || !this.sessionExpiry) {
      return false
    }
    // Consider session expired 5 minutes before actual expiry
    const buffer = 5 * 60 * 1000
    return this.sessionExpiry.getTime() - buffer > Date.now()
  }

  // ==========================================================================
  // Public API
  // ==========================================================================

  /**
   * Login to MeF service
   */
  async login(): Promise<LoginResponse> {
    const body = `
      <mef:ETIN>${this.config.credentials.etin}</mef:ETIN>
      <mef:AppSysId>${this.config.credentials.appSystemId}</mef:AppSysId>
    `

    const response = await this.executeRequest('Login', body)
    const parser = new SoapResponseParser(response)

    const sessionId = parser.extractElement('SessionId')
    const expirationStr = parser.extractElement('ExpirationTime')

    if (!sessionId) {
      throw new MeFError(
        'Login response missing session ID',
        'Authentication',
        'INVALID_RESPONSE',
        { details: response }
      )
    }

    this.sessionId = sessionId
    this.sessionExpiry = expirationStr
      ? new Date(expirationStr)
      : new Date(Date.now() + 30 * 60 * 1000) // Default 30 minutes

    return {
      sessionId: this.sessionId,
      expirationTime: this.sessionExpiry,
      etin: this.config.credentials.etin
    }
  }

  /**
   * Logout from MeF service
   */
  async logout(): Promise<void> {
    if (!this.sessionId) {
      return
    }

    const body = `
      <mef:SessionId>${this.sessionId}</mef:SessionId>
    `

    try {
      await this.executeRequest('Logout', body)
    } finally {
      this.sessionId = null
      this.sessionExpiry = null
    }
  }

  /**
   * Submit a tax return
   */
  async submitReturn(submission: ReturnSubmission): Promise<SubmitResponse> {
    if (!this.isSessionValid()) {
      await this.login()
    }

    let stateSubmissionsXml = ''
    if (submission.stateSubmissions) {
      stateSubmissionsXml = submission.stateSubmissions
        .map(
          (s) => `
        <mef:StateSubmission>
          <mef:StateCode>${s.stateCode}</mef:StateCode>
          <mef:SubmissionId>${s.submissionId}</mef:SubmissionId>
          <mef:ReturnData>${s.returnData}</mef:ReturnData>
        </mef:StateSubmission>
      `
        )
        .join('')
    }

    const body = `
      <mef:SessionId>${this.sessionId ?? ''}</mef:SessionId>
      <mef:SubmissionId>${submission.submissionId}</mef:SubmissionId>
      <mef:TaxYear>${submission.taxYear}</mef:TaxYear>
      <mef:ReturnType>${submission.returnType}</mef:ReturnType>
      <mef:ReturnData>${submission.returnData}</mef:ReturnData>
      <mef:TaxpayerTin>${submission.taxpayerTin}</mef:TaxpayerTin>
      ${
        stateSubmissionsXml
          ? `<mef:StateSubmissions>${stateSubmissionsXml}</mef:StateSubmissions>`
          : ''
      }
    `

    const response = await this.executeRequest('SubmitReturn', body)
    const parser = new SoapResponseParser(response)

    const receiptId = parser.extractElement('ReceiptId')
    const timestampStr = parser.extractElement('Timestamp')
    const status = parser.extractElement('Status') as SubmitResponse['status']

    if (!receiptId) {
      throw new MeFError(
        'Submit response missing receipt ID',
        'Validation',
        'INVALID_RESPONSE',
        { details: response }
      )
    }

    // Parse any errors
    const errors = this.parseSubmissionErrors(parser)

    return {
      submissionId: submission.submissionId,
      timestamp: timestampStr ? new Date(timestampStr) : new Date(),
      receiptId,
      status: status || 'Received',
      errors: errors.length > 0 ? errors : undefined
    }
  }

  /**
   * Parse submission errors from response
   */
  private parseSubmissionErrors(parser: SoapResponseParser): SubmissionError[] {
    const errors: SubmissionError[] = []
    const errorElements = parser.extractElements('Error')

    for (const errorXml of errorElements) {
      const errorParser = new SoapResponseParser(errorXml)
      const errorCode = errorParser.extractElement('ErrorCode') || 'UNKNOWN'
      const errorMessage =
        errorParser.extractElement('ErrorMessage') || 'Unknown error'
      const errorCategory =
        (errorParser.extractElement(
          'ErrorCategory'
        ) as SubmissionError['errorCategory']) || 'System'
      const xpath = errorParser.extractElement('XPath')

      errors.push({
        errorCode,
        errorMessage,
        errorCategory,
        xpath
      })
    }

    return errors
  }

  /**
   * Get acknowledgment for a submission
   */
  async getAcknowledgment(submissionId: string): Promise<Acknowledgment> {
    if (!this.isSessionValid()) {
      await this.login()
    }

    const body = `
      <mef:SessionId>${this.sessionId ?? ''}</mef:SessionId>
      <mef:SubmissionId>${submissionId}</mef:SubmissionId>
    `

    const response = await this.executeRequest('GetAcknowledgment', body)
    return this.parseAcknowledgment(response)
  }

  /**
   * Get status of a submission
   */
  async getSubmissionStatus(submissionId: string): Promise<SubmissionStatus> {
    if (!this.isSessionValid()) {
      await this.login()
    }

    const body = `
      <mef:SessionId>${this.sessionId ?? ''}</mef:SessionId>
      <mef:SubmissionId>${submissionId}</mef:SubmissionId>
    `

    const response = await this.executeRequest('GetSubmissionStatus', body)
    const parser = new SoapResponseParser(response)

    const status =
      (parser.extractElement('Status') as SubmissionStatus['status']) ||
      'Processing'
    const lastUpdatedStr = parser.extractElement('LastUpdated')
    const ackAvailable = parser.extractElement('AcknowledgmentAvailable')

    return {
      submissionId,
      status,
      lastUpdated: lastUpdatedStr ? new Date(lastUpdatedStr) : new Date(),
      acknowledgmentAvailable: ackAvailable === 'true'
    }
  }

  /**
   * Get all new acknowledgments
   */
  async getNewAcknowledgments(): Promise<Acknowledgment[]> {
    if (!this.isSessionValid()) {
      await this.login()
    }

    const body = `
      <mef:SessionId>${this.sessionId ?? ''}</mef:SessionId>
    `

    const response = await this.executeRequest('GetNewAcknowledgments', body)
    const parser = new SoapResponseParser(response)
    const acknowledgments: Acknowledgment[] = []

    const ackElements = parser.extractElements('Acknowledgment')
    for (const ackXml of ackElements) {
      try {
        acknowledgments.push(this.parseAcknowledgment(ackXml))
      } catch (error) {
        log.warn(`Failed to parse acknowledgment: ${String(error)}`)
      }
    }

    return acknowledgments
  }

  /**
   * Parse acknowledgment from XML
   */
  private parseAcknowledgment(xml: string): Acknowledgment {
    const parser = new SoapResponseParser(xml)

    const submissionId = parser.extractElement('SubmissionId')
    const status =
      (parser.extractElement('Status') as AcknowledgmentStatus) || 'Pending'
    const timestampStr = parser.extractElement('Timestamp')
    const acceptanceStatus = parser.extractElement(
      'AcceptanceStatus'
    ) as Acknowledgment['acceptanceStatus']

    if (!submissionId) {
      throw new MeFError(
        'Acknowledgment missing submission ID',
        'Validation',
        'INVALID_RESPONSE',
        { details: xml }
      )
    }

    // Parse errors
    const errors: AcknowledgmentError[] = []
    const errorElements = parser.extractElements('AcknowledgmentError')
    for (const errorXml of errorElements) {
      const errorParser = new SoapResponseParser(errorXml)
      errors.push({
        errorCode: errorParser.extractElement('ErrorCode') || 'UNKNOWN',
        errorMessage:
          errorParser.extractElement('ErrorMessage') || 'Unknown error',
        ruleNumber: errorParser.extractElement('RuleNumber'),
        severity:
          (errorParser.extractElement(
            'Severity'
          ) as AcknowledgmentError['severity']) || 'Error'
      })
    }

    // Parse state acknowledgments
    const stateAcks: StateAcknowledgment[] = []
    const stateElements = parser.extractElements('StateAcknowledgment')
    for (const stateXml of stateElements) {
      const stateParser = new SoapResponseParser(stateXml)
      const stateCode = stateParser.extractElement('StateCode')
      const stateSubmissionId = stateParser.extractElement('SubmissionId')

      if (stateCode && stateSubmissionId) {
        stateAcks.push({
          stateCode,
          submissionId: stateSubmissionId,
          status:
            (stateParser.extractElement('Status') as AcknowledgmentStatus) ||
            'Pending'
        })
      }
    }

    return {
      submissionId,
      status,
      timestamp: timestampStr ? new Date(timestampStr) : new Date(),
      acceptanceStatus,
      errors: errors.length > 0 ? errors : undefined,
      stateAcknowledgments: stateAcks.length > 0 ? stateAcks : undefined
    }
  }

  /**
   * Get state submission data
   */
  async getStateSubmission(submissionId: string): Promise<StateSubmission> {
    if (!this.isSessionValid()) {
      await this.login()
    }

    const body = `
      <mef:SessionId>${this.sessionId ?? ''}</mef:SessionId>
      <mef:SubmissionId>${submissionId}</mef:SubmissionId>
    `

    const response = await this.executeRequest('GetStateSubmission', body)
    const parser = new SoapResponseParser(response)

    const stateCode = parser.extractElement('StateCode')
    const returnData = parser.extractElement('ReturnData')
    const status = parser.extractElement('Status')

    if (!stateCode || !returnData) {
      throw new MeFError(
        'State submission response missing required data',
        'Validation',
        'INVALID_RESPONSE',
        { details: response }
      )
    }

    return {
      submissionId,
      stateCode,
      returnData,
      status: status || 'Unknown'
    }
  }

  /**
   * Get current session ID (if any)
   */
  getSessionId(): string | null {
    return this.sessionId
  }

  /**
   * Check if client has an active session
   */
  hasActiveSession(): boolean {
    return this.isSessionValid()
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a MeF client for ATS (Assurance Testing System) environment
 */
export function createATSClient(credentials: MeFCredentials): MeFClient {
  return new MeFClient({
    environment: 'ATS',
    credentials
  })
}

/**
 * Create a MeF client for Production environment
 */
export function createProductionClient(credentials: MeFCredentials): MeFClient {
  return new MeFClient({
    environment: 'Production',
    credentials
  })
}
